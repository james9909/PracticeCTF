import gmpy

n = 374159235470172130988938196520880526947952521620932362050308663243595788308583992120881359365258949723819911758198013202644666489247987314025169670926273213367237020188587742716017314320191350666762541039238241984934473188656610615918474673963331992408750047451253205158436452814354564283003696666945950908549197175404580533132142111356931324330631843602412540295482841975783884766801266552337129105407869020730226041538750535628619717708838029286366761470986056335230171148734027536820544543251801093230809186222940806718221638845816521738601843083746103374974120575519418797642878012234163709518203946599836959811

e = 3
c = 2205316413931134031046440767620541984801091216351222789180593875373829950860542792110364325728088504479780803714561464250589795961097670884274813261496112882580892020487261058118157619586156815531561455215290361274334977137261636930849125

c = gmpy.mpz(c)
m = c.root(3)[0]
print(("%x" % m).decode("hex"))

"""
Since e is a small number and N is very large, it seems likely that the ciphertext is vulnerable to a low exponent attack.
If m^e is less than N, then the modular arithmetic doesn't even get triggered in the first place, so we can just calculate
the e-th root of the ciphertext to retrieve the plaintext.

picoCTF{e_w4y_t00_sm411_9f5d2464}
"""
